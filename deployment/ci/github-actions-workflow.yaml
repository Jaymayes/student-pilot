# GitHub Actions Workflow for ScholarLink Production Deployment
# Includes pre-deploy gates, canary deployment, and rollback capability

name: ScholarLink Production Deployment

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      deployment_type:
        description: 'Deployment type'
        required: true
        default: 'canary'
        type: choice
        options:
        - canary
        - direct
        - rollback

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/scholarlink
  KUBERNETES_NAMESPACE: scholarlink-prod

jobs:
  # Pre-deploy validation gates
  pre-deploy-gates:
    name: Pre-Deploy Validation Gates
    runs-on: ubuntu-latest
    if: github.event.inputs.deployment_type != 'rollback'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run unit tests
      run: npm test
    
    - name: Run QA test suite
      run: npm run test:qa
    
    - name: Build application
      run: npm run build
    
    - name: Security scan
      run: npm audit --audit-level moderate
    
    - name: Run pre-deploy validation
      run: |
        # Start application in background
        npm run dev &
        APP_PID=$!
        
        # Wait for app to start
        timeout 30 bash -c 'until curl -f http://localhost:5000/health; do sleep 2; done'
        
        # Run validation gates
        ./go-live-acceptance-test.sh
        
        # Cleanup
        kill $APP_PID
    
    outputs:
      gates-passed: ${{ steps.validation.outcome == 'success' }}

  # Build and push container image
  build-and-push:
    name: Build and Push Container
    runs-on: ubuntu-latest
    needs: pre-deploy-gates
    if: needs.pre-deploy-gates.outputs.gates-passed == 'true'
    
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ steps.meta.outputs.tags }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Login to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
    
    - name: Build and push
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64
    
    - name: Sign container image
      uses: sigstore/cosign-installer@v3
    
    - name: Sign the published image
      env:
        COSIGN_EXPERIMENTAL: 1
      run: |
        cosign sign --yes ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}

  # Staging deployment and testing
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: staging
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
    
    - name: Configure kubeconfig
      run: |
        echo "${{ secrets.KUBECONFIG_STAGING }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
    
    - name: Deploy to staging
      run: |
        export KUBECONFIG=kubeconfig
        export IMAGE_DIGEST="${{ needs.build-and-push.outputs.image-digest }}"
        export DEPLOYMENT_VERSION="${{ github.sha }}"
        
        # Apply staging configuration
        envsubst < deployment/kubernetes/production-deployment.yaml | \
          sed 's/scholarlink-prod/scholarlink-staging/g' | \
          kubectl apply -f -
        
        # Wait for deployment
        kubectl rollout status deployment/scholarlink-app -n scholarlink-staging --timeout=300s
    
    - name: Run staging tests
      run: |
        export KUBECONFIG=kubeconfig
        
        # Get staging ingress URL
        STAGING_URL=$(kubectl get ingress scholarlink-ingress -n scholarlink-staging -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        
        # Run comprehensive tests against staging
        BASE_URL="https://$STAGING_URL" ./go-live-acceptance-test.sh
    
    - name: Staging smoke tests
      run: |
        export KUBECONFIG=kubeconfig
        STAGING_URL=$(kubectl get ingress scholarlink-ingress -n scholarlink-staging -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        
        # Test critical paths
        curl -f "https://$STAGING_URL/health"
        curl -f "https://$STAGING_URL/api/auth/user" || echo "Expected 401 - OK"
        
        # Test rate limiting
        for i in {1..10}; do
          curl -s -o /dev/null -w "%{http_code}\n" "https://$STAGING_URL/api/auth/user"
        done | tail -1 | grep -q "429" && echo "Rate limiting works"

  # Production canary deployment
  deploy-production-canary:
    name: Deploy Production Canary
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-staging]
    environment: production
    if: github.event.inputs.deployment_type == 'canary' || (github.event.inputs.deployment_type == '' && github.ref == 'refs/heads/main')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
    
    - name: Configure kubeconfig
      run: |
        echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
    
    - name: Run database migration
      run: |
        export KUBECONFIG=kubeconfig
        export IMAGE_DIGEST="${{ needs.build-and-push.outputs.image-digest }}"
        export DEPLOYMENT_VERSION="${{ github.sha }}"
        
        # Apply migration job
        envsubst < deployment/ci/db-migration-job.yaml | kubectl apply -f -
        
        # Wait for migration to complete
        kubectl wait --for=condition=complete job/scholarlink-db-migrate-${{ github.sha }} -n ${{ env.KUBERNETES_NAMESPACE }} --timeout=600s
    
    - name: Run canary deployment
      run: |
        export KUBECONFIG=kubeconfig
        export IMAGE_DIGEST="${{ needs.build-and-push.outputs.image-digest }}"
        export DEPLOYMENT_VERSION="${{ github.sha }}"
        export SLACK_WEBHOOK="${{ secrets.SLACK_WEBHOOK }}"
        
        # Run progressive canary deployment
        ./deployment/scripts/canary-deploy.sh "${{ github.sha }}" "${{ needs.build-and-push.outputs.image-digest }}"
    
    - name: Post-deployment verification
      run: |
        export KUBECONFIG=kubeconfig
        
        # Verify production health
        PROD_URL=$(kubectl get ingress scholarlink-ingress -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        
        # Health check
        curl -f "https://$PROD_URL/health"
        
        # Check deployment version
        curl -s "https://$PROD_URL/health" | jq -r '.version'
        
        # Verify metrics endpoint
        kubectl port-forward -n ${{ env.KUBERNETES_NAMESPACE }} deployment/scholarlink-app 9090:5000 &
        sleep 10
        curl -f "http://localhost:9090/metrics"

  # Direct production deployment (bypass canary)
  deploy-production-direct:
    name: Deploy Production Direct
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-staging]
    environment: production
    if: github.event.inputs.deployment_type == 'direct'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
    
    - name: Configure kubeconfig
      run: |
        echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
    
    - name: Deploy to production
      run: |
        export KUBECONFIG=kubeconfig
        export IMAGE_DIGEST="${{ needs.build-and-push.outputs.image-digest }}"
        export DEPLOYMENT_VERSION="${{ github.sha }}"
        
        # Update production deployment
        kubectl set image deployment/scholarlink-app -n ${{ env.KUBERNETES_NAMESPACE }} \
          scholarlink="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-and-push.outputs.image-digest }}"
        
        # Wait for rollout
        kubectl rollout status deployment/scholarlink-app -n ${{ env.KUBERNETES_NAMESPACE }} --timeout=600s

  # Rollback production deployment
  rollback-production:
    name: Rollback Production
    runs-on: ubuntu-latest
    environment: production
    if: github.event.inputs.deployment_type == 'rollback'
    
    steps:
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
    
    - name: Configure kubeconfig
      run: |
        echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
    
    - name: Rollback deployment
      run: |
        export KUBECONFIG=kubeconfig
        
        # Rollback to previous version
        kubectl rollout undo deployment/scholarlink-app -n ${{ env.KUBERNETES_NAMESPACE }}
        
        # Wait for rollback to complete
        kubectl rollout status deployment/scholarlink-app -n ${{ env.KUBERNETES_NAMESPACE }} --timeout=300s
    
    - name: Verify rollback
      run: |
        export KUBECONFIG=kubeconfig
        
        # Check health after rollback
        PROD_URL=$(kubectl get ingress scholarlink-ingress -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        curl -f "https://$PROD_URL/health"
        
        echo "âœ… Rollback completed successfully"