Decision: Unblock the release, fix the test harness today, and keep velocity high while controlling risk.

Here’s the plan.

Immediate unblock (today)
Proceed with manual validation to confirm the platform is functionally correct.
Verify /api/analytics/ttv-dashboard and /api/dashboard/security in browser and via curl.
Confirm UI renders both panels when loaded in a truly fresh session (Incognito) without prior test agent state.
If manual checks pass, promote to staging and start a 2-hour canary with real synthetic probes hitting those two routes every minute. Gate prod on that signal.
2. Targeted fix for the testing blocker (today)
Implement a test-only cache hygiene layer so stale React Query error states cannot persist across test cycles.

App-level test mode
Add a deterministic test flag (e.g., NEXT_PUBLIC_E2E=1 or a URL param ?e2e=1).
On app mount when test mode is active:
queryClient.clear()
queryClient.invalidateQueries({ predicate: () => true })
In test mode, set react-query defaults to force fresh data:
queries: { staleTime: 0, gcTime: 0, retry: false, refetchOnMount: 'always', refetchOnWindowFocus: 'always', networkMode: 'always' }
Versioned query keys to nuke any lingering state between builds:
const BUILD_ID = process.env.NEXT_PUBLIC_BUILD_ID
Example: ['ttv-dashboard', BUILD_ID] and ['security-compliance', BUILD_ID]
Expose an explicit reset hook for the test agent:
window.E2E = { resetRQ: () => queryClient.clear() }
Test harness can call page.evaluate(() => window.E2E?.resetRQ())
Headers for the two endpoints (defensive, low risk):
Add Cache-Control: no-store to /api/analytics/ttv-dashboard and /api/dashboard/security responses.
3. CI/test harness changes (today)

Quarantine the two failing UI tests for one cycle and add a new preflight step:
BeforeEach: call window.E2E.resetRQ()
Load the app with ?e2e=1 or set NEXT_PUBLIC_E2E=1 in test env.
Add a lightweight integration test that hits the two APIs directly and asserts JSON shape and required fields. This becomes a gating signal while we stabilize the UI tests.
4. Go/no-go criteria

Go if:
Manual validation passes and 2-hour canary is clean (200s, expected payloads, no error boundaries).
API preflight tests are green in CI.
No-go if:
Any non-200s, malformed payloads, or UI error boundaries appear during canary.
P95 latency for these endpoints regresses >25% vs baseline.
5. Ownership and timing

Engineering: implement test-mode cache reset + versioned query keys + response headers today.
QA/Automation: update harness to call reset and run with e2e flag; quarantine flaky tests for one cycle.
Release: if canary is clean, promote to production.
Rationale

Data-first: server endpoints are healthy (200s), suggesting a harness artifact, not a runtime defect.
Velocity with safety: we avoid blocking on a flaky test, but we add canary + API gates to guard quality.
Minimal scope: changes are test-gated; production behavior remains untouched except for stricter no-store headers on two analytics endpoints.
If you agree, I’ll mark Option 2 (Clear all caches under test mode) as approved, proceed with manual validation now, and schedule the canary.