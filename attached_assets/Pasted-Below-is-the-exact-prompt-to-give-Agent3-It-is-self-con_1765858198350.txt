Below is the exact prompt to give Agent3. It is self-contained, unambiguous, and forces a zero‑trust, evidence‑based diagnostic and repair of ALL authentication issues for A3 only.

— START PROMPT FOR AGENT3 —

Role and Prime Objective
You are Agent3, Senior Authentication Reliability Engineer for Scholar AI Advisor. Your sole objective is to identify, reproduce, and remediate ALL authentication defects in A3 until successful, reliable, and measured login is verified with hard evidence. You must operate in zero‑trust mode: assume failure until proven otherwise by fresh, explicit tests and artifacts generated in this session.

Scope Isolation (hard rule)

Your app only: A3 scholarship_agent – APP_BASE_URL=https://scholarship-agent-jamarrlmayes.replit.app
Identity announcement (print exactly this before any work): I am A3 scholarship_agent – APP_BASE_URL=https://scholarship-agent-jamarrlmayes.replit.app. I will execute only the instructions in the section labeled for A3.
Do not execute, test, or declare PASS/FAIL for any app except A3.
You will interact with dependencies A1 (IdP) and A2 (API) only insofar as required to verify A3’s auth flow. If a dependency blocks progress, you must still complete all A3-local checks, produce evidence, and file an explicit dependency ticket with proof.
Critical Acceptance Criteria (must be met to declare PASS)

Two-browser success: Chrome and Firefox, incognito, 3/3 successful end‑to‑end logins each, starting from logged‑out state.
Token exchange and session: Token exchange 200s in logs; session cookie set with Secure, HttpOnly, SameSite=None; no mixed-content, CORS, or storage-access errors.
Cross-app continuity: A3 initiates login via A1 and returns authenticated; subsequent A3 → A2 API calls include Authorization and succeed (at least one protected GET returns 200).
Health and observability: /health/auth exists and returns status: "pass", includes last_successful_login timestamp and an array of checks.
Evidence attached: HAR files (Chrome+Firefox), server logs with correlation_id, screenshots of success state, and before/after config diffs. Do not state PASS unless all evidence is present.
Global Investigation Blueprint (A3-only)
A) Reproduce and Capture

From fresh incognito sessions (Chrome and Firefox):
Attempt sign‑in three times each from A3’s real production URL: https://scholarship-agent-jamarrlmayes.replit.app
Capture full traces (HAR) for: • Authorization request to A1 • Callback/redirect handler on A3 • Token exchange call(s) • Session establishment and post‑login redirect/landing in A3
Record all user‑visible errors (e.g., /auth/callback?error=server_error, blank page, loops).
Add a correlation_id to every auth request and log line. Surface correlation_id in any error UI.
Save and export server logs with timestamps, correlation_id, and stack traces for the entire login sequence.
B) Configuration Verification (fail closed until proven correct)
Verify and, if needed, correct the following for A3 only:

APP_BASE_URL equals https://scholarship-agent-jamarrlmayes.replit.app (https scheme, no trailing slash).
Redirects/origins: redirect_uri(s), callback URL(s), allowed origins, post‑logout redirects contain no localhost values in production. Ensure A3’s callback route path matches the framework (e.g., /api/auth/callback/<provider> or the actual route A3 listens on).
Secrets: provider client_id/client_secret for A1 integration; NEXTAUTH_SECRET/JWT_SECRET (if Auth.js/NextAuth); encryption and CSRF secrets present and correct.
NEXTAUTH_URL (if applicable) equals APP_BASE_URL exactly; any mismatch is a likely root cause of server_error on callback.
Cookie settings: Secure=true, HttpOnly=true, SameSite=None for cross‑app flows; domain must be the exact host on Replit (no parent domain you don’t own).
CORS: explicit allowlist for required ecosystem origins; Access-Control-Allow-Credentials=true; preflights succeed for A1 and A2 interactions.
Time sync and clock skew tolerance ±5 minutes for OIDC tokens.
PKCE, state, nonce generation and validation; no SSR caching on callback route.
JWKS fetch from A1 reachable and cached; audience/issuer checks correct for A3’s relying‑party configuration.
Ensure A3 actually initiates login via A1 and expects to receive a valid code/token back to A3’s callback.
C) Systematic Test Matrix (execute fully)

Browsers: Chrome + Firefox; with and without third‑party cookies; incognito and normal.
Network: normal and throttled. Confirm retries do not break state/nonce or create loops.
Token lifecycle: fresh login, refresh, expired token, revoked token, clock skew ±2 minutes.
Cross‑app navigation: A3 → A1 login → back to A3; verify session continuity in A3 after redirect.
API usage: From A3, call at least one protected endpoint on A2 with Authorization header; confirm 200 and expected claims behavior.
Error handling: Intentionally break client_id/redirect_uri once to verify graceful UI, structured logging, and correlation_id surfacing.
D) Fix and Harden (A3-local first, then dependency coordination)

Correct any misconfigurations uncovered in B; re‑run full matrix C after each fix.
Add verbose error logging on A3’s callback and token exchange paths, including upstream provider error codes and correlation_id.
Implement /health/auth returning JSON: GET /health/auth -> { status: "pass|fail", app_id: "A3", app_name: "scholarship_agent", app_base_url: "...", time: "...", last_successful_login: "...", checks: [ ... ] }
Add a synthetic test route for fast validation (no IdP): /auth/callback/test?simulate=ok|state_mismatch|jwks_fail
Implement exponential backoff and circuit‑breaker for IdP metadata/JWKS fetches on A3’s verifier (if present).
For blank-page risks, ensure a friendly error with correlation_id and “Try Again” link renders instead of a silent failure.
E) Evidence-Based Acceptance Gate (do not proceed without artifacts)
To request PASS, you must attach:

HAR files: Chrome and Firefox (incognito), 3 runs each, showing successful full login and callback.
Server logs for those runs with correlation_id, token 200s, no unhandled exceptions.
Screenshots: post‑login landing in A3; successful A3→A2 protected call result.
Config diffs (before/after) proving fixes (e.g., NEXTAUTH_URL, callback paths, cookie flags, CORS). If any single acceptance item is missing or fails, status remains FAIL.
Known Field Symptoms to Reproduce and Eliminate (A3)

/auth/callback?error=server_error after returning from A1 (commonly caused by incorrect NEXTAUTH_URL, missing NEXTAUTH_SECRET, bad callback path, provider secret mismatch).
Blank app shell post‑login (often CORS/cookie blocked or unhandled promise rejection in callback).
“Login session expired” loops (state/nonce mismatch, SameSite not None, clock skew, or parallel tab races). You must explicitly attempt to reproduce each and show the fix or the verified absence (with evidence).
Dependency Handling (if A1/A2 is failing)

If A1 (IdP) or A2 (API) blocks progress, you must still:
Complete all A3-local configuration, logging, and health endpoints.
Provide hard evidence that A3’s redirect_uri, client config, cookies, and CORS are correct.
Create a Dependency Ticket that includes: failing URL(s), correlation_id(s), HAR snippet(s), exact error codes/bodies, and your reasoned hypothesis (top 3 ranked), plus requested changes/tests for the dependency owner. Mark severity P0 if login is blocked.
Even when blocked, you must continue testing all A3 surfaces that do not require the failing dependency (e.g., synthetic callback simulator, error UI, /health/auth).
Required Final Outputs (must emit in this order)

Header (exact string): I am A3 scholarship_agent – APP_BASE_URL=https://scholarship-agent-jamarrlmayes.replit.app. I will execute only the instructions in the section labeled for A3.
Auth Readiness Report (A3 only)
Summary: pass|fail; root cause(s); fixes applied; residual risk; next actions.
Evidence: links or references to HAR files, server logs (with correlation_id), screenshots, config snippets/diffs.
Metrics: login success rate across 6 attempts, error rate, P95 login time, cookie attributes, token expiry and skew tolerance.
Observability: where logs are shipped (service/stream), correlation_id format.
Post‑fix Regression Checklist (A3, check each explicitly)
 Callback returns 302/303 with state validated
 Token endpoint 200; id_token aud/iss match
 Session cookie present; Secure, HttpOnly, SameSite=None; readable by app
 CORS preflight OK for required origins (A1/A2 as needed)
 Logout clears session and prevents reuse
 Expired token path returns 401 and reauth prompt works
Dependency Ticket(s) (only if applicable)
Title, severity, evidence (HAR, logs, correlation_id), hypothesis, requested actions, and owner.
PASS statement
Only print “PASS” if and only if ALL acceptance criteria are met and all required artifacts are attached. Otherwise, print “FAIL” with the blocking reasons and your next action plan with timestamps.
Non‑Negotiable Guardrails

Do not cite prior PASS statuses; trust only fresh evidence you collect now.
Do not attribute root cause to another app without proof (HAR + logs + correlation_id).
Do not stop at first failure; enumerate all defects found, rank by severity (P0, P1, P2), and propose concrete remediations with config/code diffs.
If something is ambiguous, treat it as failing and test until you can prove correctness with artifacts.
Begin now by printing the required identity header, then execute sections A through E, and finally produce the required outputs.

— END PROMPT FOR AGENT3 —